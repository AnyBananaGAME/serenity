import { resolve } from "node:path";
import { writeFileSync } from "node:fs";

import { BLOCK_STATES, BLOCK_TYPES } from "@serenityjs/data";

const enums = resolve(__dirname, "../src/enums");
const types = resolve(__dirname, "../src/types");

// Generate a enum definition for the block identifier.
let BlockIdentifierFile = `// WARNING, DO NOT EDIT!\n// This file is automatically generated on start up.\n\n`;

BlockIdentifierFile += `export enum BlockIdentifier {\n`;

for (const type of BLOCK_TYPES) {
	// TitleCase the identifier.
	const name = type.identifier
		.split(":")[1]
		?.split("_")
		.map((word) => word[0]?.toUpperCase() + word.slice(1))
		.join("");

	BlockIdentifierFile += `	${name} = "${type.identifier}",\n`;
}

BlockIdentifierFile += `}\n`;

writeFileSync(resolve(enums, "identifier.ts"), BlockIdentifierFile);

let BlockStatesFile = `// WARNING, DO NOT EDIT!\n// This file is automatically generated on start up.\n\n`;

// Generate a type definition for the block state.
for (const state of BLOCK_STATES) {
	// Convert the snake case identifier to TitleCase.
	const name = state.identifier
		.replaceAll(":", "")
		.split("_")
		.map((word) => word[0]?.toUpperCase() + word.slice(1))
		.join("");

	// Get the states type. (string | number | boolean)
	const type = state.values.every((value) => typeof value === "string")
		? "string"
		: state.values.every((value) => typeof value === "number")
			? "number"
			: "boolean";

	// Check if the values are strings.
	const states = state.values.map((value) => {
		if (typeof value === "string") return `"${value}"`;
		return value;
	});

	// If the type isn't a string, then we will skip it.
	if (type !== "string") continue;

	// Generate the state definition.
	BlockStatesFile += `export type ${name} = ${states.join(" | ")};\n`;
}

writeFileSync(resolve(types, "states.ts"), BlockStatesFile);

// Generate block state for each type.
let BlocksFile = `// WARNING, DO NOT EDIT!\n// This file is automatically generated on start up.\n\n`;

// Iterate over the block types and generate the block state.
for (const type of BLOCK_TYPES) {
	if (type.states.length === 0) continue;

	const name = type.identifier
		.split(":")[1]
		?.split("_")
		.map((word) => word[0]?.toUpperCase() + word.slice(1))
		.join("");

	// Generate a type definition for the block state.
	BlocksFile += `export interface ${name + "Block"} {\n`;

	// Get the states for the block type.
	const states = type.states.map((state) => {
		return BLOCK_STATES.find((s) => s.identifier === state);
	}) as typeof BLOCK_STATES;

	// Iterate over the block states and generate the state.
	for (const state of states) {
		// Get the state name.
		const stateName = state.identifier
			.replaceAll(":", "")
			.split("_")
			.map((word) => word[0]?.toUpperCase() + word.slice(1))
			.join("");

		// Get the state type. (string | number | boolean)
		const type = state.values.every((value) => typeof value === "string")
			? "string"
			: state.values.every((value) => typeof value === "number")
				? "number"
				: "boolean";

		BlocksFile += state?.identifier.includes(":")
			? type === "string"
				? `	"${state.identifier}"?: import("./states").${stateName};\n`
				: `	"${state.identifier}"?: ${type.replaceAll('"', "")};\n`
			: type === "string"
				? `	${state?.identifier}?: import("./states").${stateName};\n`
				: `	${state?.identifier}?: ${type.replaceAll('"', "")};\n`;
		// ? `	"${state.identifier}"?: import("./states").${stateName};\n`
		// : `	${state?.identifier}?: import("./states").${stateName};\n`;
	}

	BlocksFile += `}\n`;
}

writeFileSync(resolve(types, "blocks.ts"), BlocksFile);

let BlockStateFile = `// WARNING, DO NOT EDIT!\n// This file is automatically generated on start up.\n\n`;

BlockStateFile += `import { BlockIdentifier } from "../enums/identifier";\n\n`;

// Generate a union interface that links the block identifier enum to the state.
BlockStateFile += `export interface BlockState {\n`;

for (const type of BLOCK_TYPES) {
	const name = type.identifier
		.split(":")[1]
		?.split("_")
		.map((word) => word[0]?.toUpperCase() + word.slice(1))
		.join("");

	BlockStateFile +=
		type.states.length === 0
			? `	[BlockIdentifier.${name}]: Record<string, string | number | boolean>;\n`
			: `	[BlockIdentifier.${name}]: import("./blocks").${name + "Block"};\n`;
}

BlockStateFile += `}\n`;

writeFileSync(resolve(types, "state.ts"), BlockStateFile);
